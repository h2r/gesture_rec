#include "ros/ros.h"
#include <tf/transform_listener.h>
#include <tf/tf.h>
#include <visualization_msgs/Marker.h> // early test visualization

visualization_msgs::MarkerArray& clusters;
/*
void clusterCallback(const visualization_msgs::MarkerArray& msg){
    clusters = msg;
}*/

int main(int argc, char **argv){
    /*
    ros::init(argc, argv, "gesture_looker");
    tf::TransformListener tfl;
    ros::NodeHandle node;
    node.subscribe("/tabletop/clusters", 1, clusterCallback);
    ros::Publisher marker_pub = node.advertise<visualization_msgs::Marker>("visualization_marker", 10); //visualization
    ros::Rate r(30); //vis
    while(node.ok()){
        tf::StampedTransform to_left_elbow;
        tf::StampedTransform to_right_elbow;
        tf::StampedTransform to_right_hand;
        tf::StampedTransform to_left_hand;
        tf::Vector3 left_vec;
        tf::Vector3 right_vec;
        tf::Vector3 left_origin;
        tf::Vector3 right_origin;
        try{
            //get all the transforms from the perspective point to the arms
            tfl.lookupTransform("/left_elbow","/openni_depth_frame", ros.time(0), to_left_elbow);
            tfl.lookupTransform("/right_elbow","/openni_depth_frame", ros.time(0), to_right_elbow);
            tfl.lookupTransform("/left_hand","/openni_depth_frame", ros.time(0), to_left_hand);
            tfl.lookupTransform("/right_hand","/openni_depth_frame", ros.time(0), to_right_hand);
            //compute vectors
            left_origin = to_left_elbow.getOrigin()
            right_origin = to_right_elbow.getOrigin()
            left_vec = Vector3(to_left_hand.getOrigin().x() - left_origin.x(),
                                to_left_hand.getOrigin().y() - left_origin.y(),
                                to_left_hand.getOrigin().z() - left_origin.z());
            right_vec = Vector3(to_right_hand.getOrigin().x() - right_origin.x(),
                                to_right_hand.getOrigin().y() - right_origin.y(),
                                to_right_hand.getOrigin().z() - right_origin.z());
            //find the closest cluster
            for(int i = 0; i<clusters.markers.size()){
                for(int j=0; j<clusters.markers[i].points.size()){

                }
            }
            //EARLY TEST VISUALIZATION
            visualization_msgs::Marker line_list;
            line_list.header.frame_id = "/my_frame"; //set to what?
            line_list.header.stamp = ros::Time::now();
            line_list.ns = "lines";
            line_list.action = visualization_msgs::Marker::ADD;
            line_list.pose.orientation.w = 1.0;
            line_list.id = 0;
            line_list.type = visualization_msgs::Marker::LINE_LIST;
            line_list.scale.x = 0.1;
            // Line list is red
            line_list.color.r = 1.0;
            line_list.color.a = 1.0;
            geometry_msgs::Point p;
            p.x = left_origin.x();
            p.y = left_origin.y();
            p.z = left_origin.z();
            line_list.push_back(p);
            p.x = to_left_hand.getOrigin().x();
            p.y = to_left_hand.getOrigin().y();
            p.z = to_left_hand.getOrigin().z();
            line_list.push_back(p);
            p.x = right_origin.x();
            p.y = right_origin.y();
            p.z = right_origin.z();
            line_list.push_back(p);
            p.x = to_right_hand.getOrigin().x();
            p.y = to_right_hand.getOrigin().y();
            p.z = to_right_hand.getOrigin().z();
            line_list.push_back(p);
            marker_pub.publish(line_list);
            // END VISUALIZATION
            r.sleep();          
        }catch(tf::TransformException ex){
           ROS_ERROR("%s",ex.what()); 
        }
    }
*/
}
